# BOJ#1504 - 특정한 최단 경로


## 느낀점
* 다익스트라에 '경로 추적'은 처음이라 이 부분만 따로 [블로그1](https://www.crocus.co.kr/1688), [블로그2](https://www.geeksforgeeks.org/printing-paths-dijkstras-shortest-path-algorithm/) [블로그3](https://developmentdiary.tistory.com/434)참조함. parent 딕셔너리를 선언하고, 최단거리t가 갱신될때마다 부모를 바꿔주면 된다고 함. 블로그에선 딕셔너리로 선언했는데, vertex 또한 숫자이므로 리스트로 적용해봄.
  * 근데 경로추적 알고보니 쓰이는 게 아니었음. 그냥 하나 알게 되었다고 생각하자 ㅎ.
* 다익스트라.. 코드를 잘못 적용해서 30분 날린듯... 최단거리테이블 갱신시, v_adj 대신 v를 넣는 바람에 그렇게 됨. 다익스트라 베이스 코드에 익숙해지자.


## notes
* 출발점, 도착점은 1, vn으로 고정
* 두 정점을 지날 수 없다면 -1 출력
* 무방향 그래프에 유의

## input
```
4 6 : v 4개, e 6개
1 2 3 : 1~2 cost 3
2 3 3 : 2~3 cost 3
3 4 1 : ...
1 3 5
2 4 5
1 4 4
2 3: v2와 v3은 무조건 거쳐야 함.
```

## output
```
7 : v2와 v3을 지나는 최단경로는 7
```

## strategy
* 최단경로면 보통 다익스트라 or bfs를 많이 썼었는데
* 가중치가 있고, 시작점이 1로 고정이니 다익스트라를 쓰자.
* 다만 두 v를 거쳐가야 하는게 핵심. 각각 a, b라고 한다면
  * 1 -> a -> b -> vn이 있을 것이고
  * 1 -> b -> a -> vn이 있을 것이다.
* 즉, 다익스트라로 구해야 할 항목은 총 5개이다.
  1. 1~a
  2. 1~b
  3. a~b
  4. a~vn
  5. b~vn
* 답은 min(<1>+<3>+<5>, <2>+<3>+<4>)
* 이를 위해선 다익스트라를 세 번 돌려야함.
* min 적용하기 전에 둘 다 무한대인 경우 -1 출력.


